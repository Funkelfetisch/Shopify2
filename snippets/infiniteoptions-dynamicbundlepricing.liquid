<script>
// Create "window.Shoppad.apps.infiniteoptions" object if it doesn't already exist
'Shoppad.apps.infiniteoptions'.split('.').reduce(function (o, x) {
  if (!o[x]) {
    o[x] = {};
  }
  return o[x];
}, window);

// Define beforeReady callback
window.Shoppad.apps.infiniteoptions.beforeReady = function (subscribe) {
  /**
   * Get parsed price object from target node
   *
   * @param {string} targetNode
   */
  var getParsedPrice = function (targetNode) {
    var parsedPrice = {
      priceElement: '',
      originalProductPrice: '',
      productPrice: '',
      productPricePrefix: '',
      productPriceSuffix: '',
    };

    parsedPrice['priceElement'] = document.querySelector(targetNode);
    parsedPrice['originalProductPrice'] = parsedPrice['priceElement'].textContent;
    parsedPrice['productPrice'] = Number(
      parsedPrice['originalProductPrice'].replace(/[^0-9\.-]+/g, '')
    ).toFixed(2);
    parsedPrice['productPricePrefix'] = parsedPrice['originalProductPrice'].substr(
      0,
      parsedPrice['originalProductPrice'].search(/\d/)
    );
    parsedPrice[
      'productPriceSuffix'
    ] = parsedPrice['originalProductPrice']
      .replace(parsedPrice['productPrice'], '')
      .replace(parsedPrice['productPricePrefix'], '');

    return parsedPrice;
  };

  /**
   * Watch for price change from third parties
   */
  var constructObserver = function () {
    if (observerSet) {
      return;
    }

    observerSet = true;

    var targetNode = document.querySelector('.product__price .product__current-price');

    // Options for the observer
    var config = { characterData: true, childList: true, subtree: true };

    // Callback function to execute when mutations are observed
    const callback = function (mutationsList) {
      for (const mutation of mutationsList) {
        var nodeAdded =
          mutation.addedNodes &&
          mutation.addedNodes.length &&
          mutation.addedNodes[0].nodeValue;

        // Check if mutation warrants a reaction
        if (
          nodeAdded &&
          mutation.type === 'childList' &&
          mutation.target.className.indexOf('money') >= 0 &&
          bundledProducts
        ) {
          // Store existing, get new price
          var existingPrice = price.productPrice;
          price = getParsedPrice('.product__price .money');

          // Exit if existing price matches updated price
          if (existingPrice === price.productPrice) {
            return;
          }

          // Update product price
          price.productPrice = (
            Number(price.productPrice) + Number(bundledPrice)
          ).toFixed(2);
          price.priceElement.textContent =
            price.productPricePrefix +
            price.productPrice +
            price.productPriceSuffix;
        }
      }
    };

    // Create an observer instance linked to the callback function
    const observer = new MutationObserver(callback);

    // Start observing the target node for configured mutations
    observer.observe(targetNode, config);
  };

  // Target price element
  var targetNode = '.price-item .money';
  // Flag to determine if the observer has been set or not
  var observerSet = false;
  // Store count of bundled produts
  var bundledProducts = 0;
  // Store total price of all bundled products
  var bundledPrice = '0.00';
  // Price object
  var price = getParsedPrice(targetNode);

  /**
   * Handle product bundle add
   */
  subscribe('productBundleAdd', function (event) {
    // Set up observer
    constructObserver();

    // Update product bundle data
    bundledProducts = bundledProducts + 1;
    bundledPrice = (
      Number(bundledPrice) + Number(event.detail.productBundle.price)
    ).toFixed(2);

    // Update product price
    price.productPrice = (
      Number(price.productPrice) + Number(event.detail.productBundle.price)
    ).toFixed(2);
    price.priceElement.textContent =
      price.productPricePrefix + price.productPrice + price.productPriceSuffix;
  });

  /**
   * Handle product bundle remove
   */
  subscribe('productBundleRemove', function (event) {
    // Update product bundle data
    bundledProducts = bundledProducts - 1;
    bundledPrice = (
      Number(bundledPrice) - Number(event.detail.productBundle.price)
    ).toFixed(2);

    // Update product price
    price.productPrice = (
      Number(price.productPrice) - Number(event.detail.productBundle.price)
    ).toFixed(2);
    price.priceElement.textContent =
      price.productPricePrefix + price.productPrice + price.productPriceSuffix;
  });
};
</script>